<script>
    const gridContainer = document.getElementById('grid-container');
    const statusDiv = document.getElementById('status');
    const canvas = document.getElementById('proc-canvas');
    const ctx = canvas.getContext('2d');

    let lastBitmap = null;
    let tesseractWorker = null; // Global worker instance

    // 1. Initialize Tesseract once on load
    (async function initOCR() {
        statusDiv.innerHTML = "Initializing OCR Engine...";
        tesseractWorker = await Tesseract.createWorker('eng');
        await tesseractWorker.setParameters({
            tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', // Removed numbers for Strands
            tessedit_pageseg_mode: '6' 
        });
        statusDiv.innerHTML = "Ready. Paste any screenshot.";
    })();

    function initGrid() {
        gridContainer.innerHTML = '';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 6; c++) {
                createCell('', r, c);
            }
        }
    }

    function createCell(char, r, c) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.innerText = char;
        cell.contentEditable = "false"; 
        cell.addEventListener('click', (e) => {
            if (cell.isContentEditable) return;
            cell.classList.toggle('selected');
        });
        cell.addEventListener('dblclick', (e) => {
            cell.contentEditable = "true";
            cell.classList.add('editing');
            cell.focus();
        });
        cell.addEventListener('blur', (e) => {
            cell.contentEditable = "false";
            cell.classList.remove('editing');
            cell.innerText = cell.innerText.toUpperCase();
        });
        gridContainer.appendChild(cell);
    }

    // --- PASTE HANDLERS ---
    async function triggerPaste() {
        try {
            const items = await navigator.clipboard.read();
            for (const item of items) {
                if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
                    const blob = await item.getType(item.types.find(t => t.startsWith('image/')));
                    processImage(blob);
                    return;
                }
            }
            alert("No image found!");
        } catch (err) {
            statusDiv.innerHTML = "Clipboard blocked. Tap 'Allow Paste'.";
        }
    }
    
    document.addEventListener('paste', (e) => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (const item of items) {
            if (item.type.indexOf('image') !== -1) {
                processImage(item.getAsFile());
                return;
            }
        }
    });

    async function processImage(blob) {
        if (!tesseractWorker) {
            statusDiv.innerHTML = "OCR still loading...";
            return;
        }
        statusDiv.innerHTML = "Processing...";
        lastBitmap = await createImageBitmap(blob);
        runProcessing();
    }

    async function runProcessing() {
        const w = lastBitmap.width;
        const h = lastBitmap.height;
        
        // Use an offscreen canvas for pixel reading
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = w;
        tempCanvas.height = h;
        const tCtx = tempCanvas.getContext('2d');
        tCtx.drawImage(lastBitmap, 0, 0);
        const imgData = tCtx.getImageData(0, 0, w, h);
        const data = imgData.data;

        // --- DENSITY CLUSTERING ---
        statusDiv.innerHTML = "Scanning layout...";
        let activeRuns = [];
        let currentRun = null;

        // Optimization: Skip scan if image is small
        const scanStepY = Math.max(1, Math.floor(h / 100)); 
        
        for(let y=0; y<h; y+=scanStepY) { 
            let rowHasBright = false;
            let brightCount = 0;
            // Scan X with larger steps for speed
            for(let x=0; x<w; x+=10) {
                const i = (y*w + x)*4;
                // Simple brightness check
                if ((data[i]+data[i+1]+data[i+2])/3 > 60) {
                    brightCount++;
                }
            }
            if(brightCount > (w/10 * 0.05)) rowHasBright = true;

            if(rowHasBright) {
                if(!currentRun) currentRun = { start: y, end: y };
                else currentRun.end = y;
            } else {
                if(currentRun) {
                    if((currentRun.end - currentRun.start) > 50) activeRuns.push(currentRun);
                    currentRun = null;
                }
            }
        }
        if(currentRun && (currentRun.end - currentRun.start) > 50) activeRuns.push(currentRun);

        // Pick Tallest Block
        let bestRun = null;
        let maxLen = 0;
        activeRuns.forEach(run => {
            const len = run.end - run.start;
            if(len > maxLen) { maxLen = len; bestRun = run; }
        });

        // Define Crop Box
        let minX=0, maxX=w, minY=0, maxY=h;

        if(bestRun) {
            minY = bestRun.start;
            maxY = bestRun.end;
            
            let realMinX = w, realMaxX = 0;
            // Scan interior for X bounds
            for(let y=minY; y<maxY; y+=10) {
                 for(let x=0; x<w; x+=10) {
                     const i = (y*w + x)*4;
                     if ((data[i]+data[i+1]+data[i+2])/3 > 60) {
                         if(x < realMinX) realMinX = x;
                         if(x > realMaxX) realMaxX = x;
                     }
                 }
            }
            
            const pad = 20; 
            minX = Math.max(0, realMinX - pad);
            maxX = Math.min(w, realMaxX + pad);
            minY = Math.max(0, minY - pad);
            maxY = Math.min(h, maxY + pad);
        }

        const gridW = maxX - minX;
        const gridH = maxY - minY;
        
        // FLOORING values to ensure clean integers for canvas operations
        const cellW = Math.floor(gridW / 6);
        const cellH = Math.floor(gridH / 8);

        // --- DARK MODE CHECK ---
        let darkPixels = 0;
        let totalPixels = 0;
        
        // Sampling just the center of the grid for speed
        const cropCanvas = document.createElement('canvas');
        cropCanvas.width = 100;
        cropCanvas.height = 100;
        const cropCtx = cropCanvas.getContext('2d');
        // Draw a thumbnail of the crop
        cropCtx.drawImage(lastBitmap, minX, minY, gridW, gridH, 0, 0, 100, 100);
        const cropData = cropCtx.getImageData(0,0,100,100).data;

        for(let i=0; i<cropData.length; i+=4) {
            const lum = (cropData[i]+cropData[i+1]+cropData[i+2])/3;
            if(lum < 80) darkPixels++; 
            totalPixels++;
        }
        const isUnsolvedMode = (darkPixels / totalPixels) > 0.4;

        // Setup Stitched Canvas
        canvas.width = 600; 
        canvas.height = 800;
        ctx.fillStyle = "white"; 
        ctx.fillRect(0,0,600,800);

        // --- STITCH STRATEGY ---
        for(let r=0; r<8; r++) {
            for(let c=0; c<6; c++) {
                const srcX = minX + (c * cellW);
                const srcY = minY + (r * cellH);
                
                const padX = Math.floor(cellW * 0.12); 
                const padY = Math.floor(cellH * 0.12);
                
                const rawCanvas = document.createElement('canvas');
                rawCanvas.width = cellW; 
                rawCanvas.height = cellH;
                const rawCtx = rawCanvas.getContext('2d');
                
                // Safe Draw: Prevent source coordinates from going out of bounds
                const sX = srcX + padX;
                const sY = srcY + padY;
                const sW = cellW - (padX*2);
                const sH = cellH - (padY*2);

                if (sX >= 0 && sY >= 0 && (sX+sW) <= w && (sY+sH) <= h) {
                    rawCtx.drawImage(lastBitmap, sX, sY, sW, sH, 0, 0, cellW, cellH);
                }

                const rawData = rawCtx.getImageData(0,0,cellW,cellH);
                const rd = rawData.data;

                // Pixel Filter
                for(let i=0; i<rd.length; i+=4) {
                    let r = rd[i], g = rd[i+1], b = rd[i+2];
                    
                    if (isUnsolvedMode) {
                        r = 255 - r; g = 255 - g; b = 255 - b;
                    }
                    
                    const lum = (r + g + b) / 3;
                    // Binarize
                    const val = lum < 150 ? 0 : 255;
                    rd[i] = rd[i+1] = rd[i+2] = val;
                }
                
                // Dilation (Bold)
                const copy = new Uint8ClampedArray(rd);
                for(let i=0; i<rd.length; i+=4) {
                    // Check if pixel is black
                    if(copy[i] === 0) {
                        // Spread black to right
                        if(i+4 < rd.length) { rd[i+4]=0; rd[i+5]=0; rd[i+6]=0; }
                        // Spread black down
                        if(i + (cellW*4) < rd.length) { 
                            const down = i + (cellW*4);
                            rd[down]=0; rd[down+1]=0; rd[down+2]=0; 
                        }
                    }
                }

                rawCtx.putImageData(rawData, 0, 0);
                // Draw to Master
                ctx.drawImage(rawCanvas, c*100 + 10, r*100 + 10, 80, 80);
            }
        }

        // --- OCR ---
        statusDiv.innerHTML = "Reading letters...";
        
        const { data: { symbols } } = await tesseractWorker.recognize(canvas);
        
        initGrid(); // Clear previous
        const finalGrid = Array(8).fill(null).map(() => Array(6).fill(''));
        let foundCount = 0;

        symbols.forEach(s => {
            const cx = (s.bbox.x0 + s.bbox.x1) / 2;
            const cy = (s.bbox.y0 + s.bbox.y1) / 2;
            const c = Math.floor(cx / 100);
            const r = Math.floor(cy / 100);

            let char = s.text.trim().toUpperCase();
            
            // Corrections
            if(char === '0') char = 'O';
            if(char === '|') char = 'I';
            if(char === '1') char = 'I';
            if(char === '5') char = 'S';
            if(char === '8') char = 'B';
            
            if (c >= 0 && c < 6 && r >= 0 && r < 8 && char.match(/[A-Z]/)) {
                 finalGrid[r][c] = char;
                 foundCount++;
            }
        });

        // Fill UI
        const cells = gridContainer.children;
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 6; c++) {
                const char = finalGrid[r][c];
                if(char) cells[r*6 + c].innerText = char;
            }
        }
        statusDiv.innerHTML = `Done! Found ${foundCount} letters.`;
    }

    initGrid();
</script>