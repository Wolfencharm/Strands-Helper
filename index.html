<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Strands Sandbox v31.0</title>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: #f4f4f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 10px;
            color: #18181b;
            overscroll-behavior: none; 
        }

        h1 { margin: 0; font-size: 1.4rem; }
        
        .version { 
            font-size: 0.9rem; 
            color: #db2777; /* Pink for v31 */
            font-weight: bold;
            margin-bottom: 15px; 
            background: #fce7f3;
            padding: 2px 8px;
            border-radius: 4px;
        }

        #status {
            background: white;
            padding: 12px;
            border-radius: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            margin-bottom: 15px;
            text-align: center;
            font-size: 14px;
            width: 90%;
            max-width: 400px;
            border: 1px solid #e4e4e7;
        }

        #grid-container {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
            padding: 12px;
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.08);
            width: 100%;
            max-width: 360px;
            touch-action: manipulation;
        }

        .cell {
            aspect-ratio: 1/1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px; 
            font-weight: 700;
            border: 2px solid #e4e4e7;
            border-radius: 50%;
            cursor: pointer;
            text-transform: uppercase;
            user-select: none;
            background: #fff;
            -webkit-tap-highlight-color: transparent;
        }

        .cell.selected { background-color: #dbeafe; border-color: #3b82f6; color: #1d4ed8; }
        .cell.editing { background-color: #fef9c3; border-color: #eab308; cursor: text; }
        .cell:empty { background-color: #fff1f2; border-color: #fecdd3; }

        .btn-group {
            display: flex;
            gap: 10px;
            width: 90%;
            max-width: 360px;
            margin-bottom: 10px;
        }

        button.primary {
            background-color: #2563eb;
            color: white;
            font-size: 16px;
            padding: 12px;
            border-radius: 12px;
            border: none;
            flex: 1;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(37, 99, 235, 0.2);
        }
        button.primary:active { transform: scale(0.98); }

        .controls { margin-top: 20px; display: flex; gap: 10px; }
        button.secondary {
            padding: 10px 16px;
            background-color: #fff;
            border: 1px solid #d4d4d8;
            border-radius: 8px;
            font-size: 13px;
            color: #52525b;
        }

        #proc-canvas { 
            display: block; 
            margin-top: 10px; 
            border: 2px solid #444; 
            max-width: 90%; 
            height: auto;
            border-radius: 8px;
            background: #000; /* Visual aid: Black bg to see the white letters */
        }
    </style>
</head>
<body>

    <h1>Strands Sandbox</h1>
    <div class="version">v31.0 (Grid Locking)</div>
    
    <div class="btn-group">
        <button class="primary" onclick="triggerPaste()">ðŸ“‹ Paste Image</button>
    </div>

    <div id="status">
        Loading Core Engine...
    </div>

    <div id="grid-container"></div>

    <div class="controls">
        <button class="secondary" onclick="clearHighlights()">Clear Path</button>
        <button class="secondary" onclick="initGrid()">Reset Board</button>
    </div>
    
    <div style="font-size:10px; color:#999; margin-top:20px">
        Robot View (Processed Input):
    </div>
    <canvas id="proc-canvas"></canvas>

    <script>
        const gridContainer = document.getElementById('grid-container');
        const statusDiv = document.getElementById('status');
        const canvas = document.getElementById('proc-canvas');
        const ctx = canvas.getContext('2d');

        let lastBitmap = null;
        let tesseractWorker = null;

        (async function initOCR() {
            try {
                tesseractWorker = await Tesseract.createWorker('eng');
                await tesseractWorker.setParameters({
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
                    tessedit_pageseg_mode: '6' 
                });
                statusDiv.innerHTML = "Ready. Paste any screenshot.";
            } catch (e) {
                statusDiv.innerHTML = "Error loading OCR. Refresh page.";
                console.error(e);
            }
        })();

        function initGrid() {
            gridContainer.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 6; c++) {
                    createCell('', r, c);
                }
            }
        }

        function createCell(char, r, c) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.innerText = char;
            cell.contentEditable = "false"; 
            cell.addEventListener('click', (e) => {
                if (cell.isContentEditable) return;
                cell.classList.toggle('selected');
            });
            cell.addEventListener('dblclick', (e) => {
                cell.contentEditable = "true";
                cell.classList.add('editing');
                cell.focus();
            });
            cell.addEventListener('blur', (e) => {
                cell.contentEditable = "false";
                cell.classList.remove('editing');
                cell.innerText = cell.innerText.toUpperCase();
            });
            gridContainer.appendChild(cell);
        }

        async function triggerPaste() {
            try {
                const items = await navigator.clipboard.read();
                for (const item of items) {
                    if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
                        const blob = await item.getType(item.types.find(t => t.startsWith('image/')));
                        processImage(blob);
                        return;
                    }
                }
                alert("No image found!");
            } catch (err) {
                statusDiv.innerHTML = "Clipboard blocked. Tap 'Allow Paste'.";
            }
        }
        
        document.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (const item of items) {
                if (item.type.indexOf('image') !== -1) {
                    processImage(item.getAsFile());
                    return;
                }
            }
        });

        async function processImage(blob) {
            if (!tesseractWorker) {
                statusDiv.innerHTML = "OCR still loading...";
                return;
            }
            statusDiv.innerHTML = "Processing...";
            lastBitmap = await createImageBitmap(blob);
            runProcessing();
        }

        async function runProcessing() {
            const w = lastBitmap.width;
            const h = lastBitmap.height;
            
            // 1. Create Analysis Canvas (Grayscale)
            const anaCanvas = document.createElement('canvas');
            anaCanvas.width = w;
            anaCanvas.height = h;
            const anaCtx = anaCanvas.getContext('2d');
            anaCtx.drawImage(lastBitmap, 0, 0);
            const imgData = anaCtx.getImageData(0, 0, w, h);
            const data = imgData.data;

            // --- V31: PROJECTION PROFILING ---
            statusDiv.innerHTML = "Locking onto grid...";

            // Determine if Dark Mode or Light Mode
            // Sample center pixel (simplistic but fast)
            const centerIdx = ((Math.floor(h/2) * w) + Math.floor(w/2)) * 4;
            const isDarkMode = data[centerIdx] < 128; // If center is dark, it's dark mode

            // Create Binary Map (White Text = 1, Black Bg = 0)
            const binaryRowSums = new Array(h).fill(0);
            const binaryColSums = new Array(w).fill(0);
            
            for(let y=0; y<h; y++) {
                for(let x=0; x<w; x++) {
                    const i = (y*w + x)*4;
                    const r = data[i], g = data[i+1], b = data[i+2];
                    const lum = (r+g+b)/3;
                    
                    let isText = false;
                    if(isDarkMode) {
                        if(lum > 100) isText = true; // Bright text on dark
                    } else {
                        if(lum < 150) isText = true; // Dark text on light
                    }

                    if(isText) {
                        binaryRowSums[y]++;
                        binaryColSums[x]++;
                    }
                }
            }

            // --- PEAK DETECTION (ROWS) ---
            // Find 8 peaks that are roughly equidistant
            function findPeaks(arr, minGap, minHeight) {
                let peaks = [];
                let inPeak = false;
                let start = 0;
                
                for(let i=0; i<arr.length; i++) {
                    if(arr[i] > minHeight) {
                        if(!inPeak) { inPeak = true; start = i; }
                    } else {
                        if(inPeak) {
                            inPeak = false;
                            const center = Math.floor((start + i) / 2);
                            // Filter tiny noise peaks
                            if ((i - start) > 5) peaks.push(center); 
                        }
                    }
                }
                return peaks;
            }

            // Adaptive thresholds
            const rowThreshold = w * 0.02; // A row must have at least 2% of width as text pixels
            const colThreshold = h * 0.01; 
            
            let rowPeaks = findPeaks(binaryRowSums, 10, rowThreshold);
            let colPeaks = findPeaks(binaryColSums, 10, colThreshold);

            // INTELLIGENT FILTERING
            // We want exactly 8 rows and 6 cols.
            // Heuristic: The grid is usually the largest cluster of peaks with consistent spacing.
            
            // Simple fallback: If we found too many, take the set with best spacing coherence
            // For now: Just taking the last 8 rows (usually grid is at bottom) if > 8
            // and the middle 6 cols.
            
            if(rowPeaks.length > 8) {
                // Check gaps. The header "Theme" usually has a huge gap before the grid.
                // We take the last 8 peaks.
                rowPeaks = rowPeaks.slice(-8); 
            }
            
            // For cols, we usually find 6. If we find more (borders?), take the 6 most central.
            if(colPeaks.length > 6) {
                const centerIdx = Math.floor(colPeaks.length / 2);
                colPeaks = colPeaks.slice(centerIdx - 3, centerIdx + 3);
            }

            if(rowPeaks.length !== 8 || colPeaks.length !== 6) {
                statusDiv.innerHTML = `Grid Align Error: Found ${rowPeaks.length}R x ${colPeaks.length}C. Try cropping closer.`;
                // Render debug view anyway so user sees what happened
            }

            // --- STITCHING (Centered Extraction) ---
            // We now have exact (x,y) centers for every letter.
            
            canvas.width = 600; 
            canvas.height = 800;
            ctx.fillStyle = "white"; 
            ctx.fillRect(0,0,600,800);

            // Estimate cell size based on gaps
            const avgRowHeight = (rowPeaks[rowPeaks.length-1] - rowPeaks[0]) / 7;
            const cropSize = Math.floor(avgRowHeight * 0.85); // 85% of row height

            for(let r=0; r<rowPeaks.length; r++) {
                for(let c=0; c<colPeaks.length; c++) {
                    const cx = colPeaks[c];
                    const cy = rowPeaks[r];
                    
                    const srcX = cx - (cropSize/2);
                    const srcY = cy - (cropSize/2);
                    
                    // Extract Cell
                    const rawCanvas = document.createElement('canvas');
                    rawCanvas.width = cropSize;
                    rawCanvas.height = cropSize;
                    const rawCtx = rawCanvas.getContext('2d');
                    
                    if(srcX >=0 && srcY>=0) {
                        rawCtx.drawImage(lastBitmap, srcX, srcY, cropSize, cropSize, 0, 0, cropSize, cropSize);
                    }
                    
                    const cellData = rawCtx.getImageData(0,0,cropSize,cropSize);
                    const cd = cellData.data;
                    
                    // Invert & Clean
                    for(let i=0; i<cd.length; i+=4) {
                        let r = cd[i], g = cd[i+1], b = cd[i+2];
                        let lum = (r+g+b)/3;
                        
                        // Normalization: Always output Black Text on White BG
                        let isBright = lum > 120;
                        if(isDarkMode) {
                            // In dark mode, text is bright. We want text to be black (0).
                            // So if bright, val = 0. Else 255.
                            val = isBright ? 0 : 255;
                        } else {
                            // In light mode, text is dark. We want text to be black (0).
                            // So if bright, val = 255. Else 0.
                            val = isBright ? 255 : 0;
                        }
                        cd[i] = cd[i+1] = cd[i+2] = val;
                    }
                    
                    // Bold Filter (Dilation) to help OCR
                    const copy = new Uint8ClampedArray(cd);
                    for(let i=0; i<cd.length; i+=4) {
                        if(copy[i] === 0) { // If black pixel
                             if(i+4 < cd.length) { cd[i+4]=0; cd[i+5]=0; cd[i+6]=0; }
                        }
                    }

                    rawCtx.putImageData(cellData, 0, 0);
                    
                    // Place into Stitch Map
                    // We standardise to 100x100 grid cells
                    ctx.drawImage(rawCanvas, c*100 + 15, r*100 + 15, 70, 70);
                }
            }

            // --- OCR ---
            statusDiv.innerHTML = "Reading letters...";
            const { data: { symbols } } = await tesseractWorker.recognize(canvas);
            
            initGrid(); 
            const finalGrid = Array(8).fill(null).map(() => Array(6).fill(''));
            let foundCount = 0;

            symbols.forEach(s => {
                const cx = (s.bbox.x0 + s.bbox.x1) / 2;
                const cy = (s.bbox.y0 + s.bbox.y1) / 2;
                const c = Math.floor(cx / 100);
                const r = Math.floor(cy / 100);
                let char = s.text.trim().toUpperCase();
                
                // Corrections
                if(char === '0') char = 'O';
                if(char === '|') char = 'I';
                if(char === '1') char = 'I';
                if(char === '5') char = 'S';
                if(char === '8') char = 'B';
                
                if (c >= 0 && c < 6 && r >= 0 && r < 8 && char.match(/[A-Z]/)) {
                     finalGrid[r][c] = char;
                     foundCount++;
                }
            });

            const cells = gridContainer.children;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 6; c++) {
                    const char = finalGrid[r][c];
                    if(char) cells[r*6 + c].innerText = char;
                }
            }
            
            if(foundCount > 0) {
                statusDiv.innerHTML = `Done! Found ${foundCount} letters.`;
            } else {
                statusDiv.innerHTML = "Retrying with looser filter...";
                // (Optional: Simple retry logic could go here)
            }
        }

        initGrid();
    </script>
</body>
</html>